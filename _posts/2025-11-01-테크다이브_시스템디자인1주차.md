---
layout: post
title: "테크다이브 시스템 디자인 1주차(단축 URL 서비스)"
categories: [시스템디자인, 테크다이브]
author: cotes
published: true
---


# 테크다이브 스터디: URL 단축 서비스 시스템 디자인 요약

테크다이브 스터디에서는 URL 단축 서비스의 시스템 디자인에 대해 심도 있는 논의를 진행했습니다. 핵심 기능 정의부터 비기능적 요구사항, 아키텍처 설계, 데이터베이스 선택, 그리고 확장성 문제까지 전반적인 내용을 다루었습니다.

---

## 1. 요구사항 정의

### 핵심 기능 (MVP)

- **URL 생성**: 긴 원본 URL을 입력받아 짧은 URL을 생성합니다.
- **리디렉션**: 짧은 URL로 접근 시, 원본 URL로 사용자를 즉시 이동시킵니다.
- **(추가 고려)**: 커스텀 URL (사용자 지정 문자열), 만료 시간 설정.

### 비기능적 요구사항

- **DAU (일일 활성 사용자)**: 100만 명
- **읽기/쓰기 비율**: 100:1
    - **일일 쓰기 (생성) 요청**: 10만 건
    - **일일 읽기 (리디렉션) 요청**: 1,000만 건
- **성능 (P99)**:
    - **쓰기**: 200ms
    - **읽기**: 50ms
- **QPS (초당 쿼리 수)**:
    - **쓰기 (평균)**: 약 1.2 QPS
    - **읽기 (평균)**: 약 116 QPS (피크 타임 고려 시 약 220 QPS)
- **데이터 저장량 (연간)**: 약 3,650만 건

---

## 2. 아키텍처 및 데이터베이스 설계

### 하이레벨 아키텍처


기본 구조는 **클라이언트 → 로드밸런서(LB) → 서비스 레이어(WAS) → 데이터베이스**로 설계되었습니다.

![BitOperations]({{ '/assets/img/favicons/IMG_0623.jpg' | absolute_url }})





### 데이터베이스 선택 및 데이터 흐름

- **메인 DB: DynamoDB (DDB)**
    - 키-값(Key-Value) 저장소의 특성이 URL 단축 서비스에 적합하며, **높은 성능**(O(1) 접근 시간)과 **비용 효율성**을 제공합니다.
    - 읽기/쓰기 요청을 모두 처리합니다.
    - URL 만료는 DDB의 **TTL(Time To Live)** 기능을 활용하여 약 1년으로 설정합니다.
- **분석/백업 DB: RDS (Aurora)**
    - DDB는 관계형 쿼리나 복잡한 통계 분석에 한계가 있습니다.
    - 따라서 **DynamoDB Streams**와 **Kinesis**를 통해 데이터를 실시간으로 RDS에 동기화합니다.
    - RDS는 데이터의 **영속성**을 관리하고, 통계 데이터 분석, 커스텀 쿼리, 회원 정보 저장 등에 활용됩니다.
- **데이터 흐름 요약:**
    - **쓰기**: Client → LB → WAS → **DynamoDB** → Kinesis → **RDS** (비동기 동기화)
    - **읽기**: Client → LB → WAS → **DynamoDB** (빠른 응답)

### 초기 논의: 트라이 (Trie) 자료구조

- 초기에는 RDB에서 트라이 자료구조를 사용하여 URL의 중복되는 도메인 부분을 압축해 저장 용량을 줄이는 방안이 논의되었습니다.
- **결론**: URL 단축 서비스는 문자열의 *접두사 검색*(예: 자동 완성)이 필요한 것이 아니라, 고유한 키(단축 URL)로 값을 *즉시 찾는 것*(O(1))이 중요합니다. 따라서 트라이는 이 서비스에 적합하지 않으며, **해시 테이블(Hash Table)** 구조가 더 효율적이라고 결론 내렸습니다.

---

## 3. 딥다이브: 단축 URL 생성 알고리즘

고유한 6자리의 단축 URL을 생성하는 방식을 논의했습니다. 개략적으로 계산했던 추정치에 따르면 이 시스템은 3650억개의 URL을 만들어낼 수 있어야 합니다.

- **형식**: **Base62 인코딩** (A-Z, a-z, 0-9, 총 62개 문자) 사용.
    - 6자리 Base62는 약 568억 개(62^6)의 고유 URL을 생성할 수 있어(스터디 중 3.5조로 계산되었으나 568억이 더 정확함), 요구사항(연 3,650만 건)을 충족하기에 충분합니다.
- **방식 1: 해시 함수 + Base62 (비효율적)**
    - 원본 URL을 MD5나 SHA로 해시한 후, 이를 Base62로 인코딩하는 방식.
    - 해시 충돌 가능성이 낮고 속도가 빠르지만(MD5), 생성된 해시가 길어 6자리로 자를 경우 충돌 위험이 커집니다. 6자리면 62진수(base-62) 기준으로 560억개, 7자리면 3.5조개의 URL 생성가능.
- **방식 2: 오토 인크리먼트(Auto-increment) ID + Base62 (채택 가능성 높음)**
    - 데이터가 생성될 때마다 증가하는 고유 숫자 ID(예: 1, 2, 3...)를 받아, 이 숫자를 Base62로 변환합니다. (예: 1000 → 'g8')
    - **문제**: DynamoDB는 오토 인크리먼트를 직접 지원하지 않습니다. (별도 카운터 구현 필요)
- **방식 3: 랜덤 생성 후 충돌 시 재시도 (논의됨)**
    - 6자리의 랜덤 문자열을 생성하고 DB에 삽입을 시도합니다.
    - **충돌 처리**: DDB의 **Conditional Write** (조건부 쓰기) 기능을 사용합니다. 만약 해당 키가 이미 존재하면(충돌 발생), 예외를 받아 새로운 랜덤 문자열로 재시도합니다.
    - 3조 개 이상의 공간에서 충돌 확률은 매우 낮으므로, 조회를 먼저 하는 것보다 일단 삽입하는 것이 효율적입니다.

---

## 4. 확장성 및 병목 현상 대응

**시나리오**: 1억 팔로워를 가진 인플루언서가 생성한 URL을 공유하여 트래픽이 폭증하는 경우.

1. **CDN (Content Delivery Network)**
    - 가장 앞단(Edge)에서 대응하는 가장 효과적인 방법입니다.
    - 동일한 URL 요청(읽기)은 **CDN에 캐싱**되어 서비스 레이어(WAS)나 DB까지 도달하지 않고 즉시 응답되므로, 서버 부하가 획기적으로 줄어듭니다.
2. **로드밸런서(LB) 및 스케일 아웃**
    - CDN을 통과한 요청을 여러 대의 WAS 인스턴스로 분산시킵니다.
    - 트래픽 증가에 따라 WAS 인스턴스 수를 **오토 스케일링(Auto-scaling)**합니다.
3. **캐시 (Redis)**
    - DDB로 가는 읽기 요청 부하를 줄이기 위해 WAS와 DDB 사이에 **레디스(Redis) 캐시**를 도입합니다.
    - 필요시 WAS **로컬 캐시**도 고려하여 DB 접근을 최소화합니다.
4. **RDS 동기화 병목 (유량 제어)**
    - 읽기/쓰기 트래픽이 폭증하면 DDB에서 Kinesis를 통해 RDS로 가는 데이터 스트림도 폭증하여 RDS가 감당하지 못하고 터질 수 있습니다.
    - **해결**: Kinesis와 RDS 사이에 **유량 제어(Rate Limiting)** 장치(예: SQS, 배치 처리)를 두어, RDS가 처리할 수 있는 만큼의 요청만 비동기적으로 천천히 보냅니다. 대량의 데이터는 S3에 JSON 객체 등으로 임시 저장 후 배치 처리하는 방식도 가능합니다.

## 5. 향후 논의 사항

- 트래픽 폭증 시 RDS 동기화 병목을 해결하기 위한 **유량 제어(Rate Limiting)** 방안에 대해 다음 스터디에서 구체적으로 논의하기로 했습니다.
