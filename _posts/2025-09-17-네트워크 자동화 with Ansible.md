### Ansible Network Automate

Cisco에서 제공하는 가이드와 실습환경을 바탕으로 Ansible을 활용해 네트워크 장비들을 수집하는 실습을 진행했습니다.

토폴로지 구조는 아래와 같습니다.

<img width="777" height="631" alt="NetworkTopologyAnsible" src="https://github.com/user-attachments/assets/1435b426-a5e1-475b-bcf1-453d9f29213b" />

1. 자동화의 시작: '누구에게(Inventory)'와 '무엇을(Playbook)' 정의하기
네트워크 자동화를 시작하기 위해선 Ansible에게 두 가지를 알려줘야 합니다. 어떤 장비에(Inventory), 그리고 어떤 작업을 할지(Playbook) 입니다.

• 인벤토리(Inventory): 작업 대상 목록 정의 인벤토리 파일은 자동화할 장비들의 목록과 접속 정보 등을 담고 있습니다. 저는 실습에서 R1, R2, R3 라우터를 cpe(Customer Premises Equipment), core와 같은 그룹으로 묶어 관리했습니다.
    ◦ 변수 활용: 모든 장비에 공통적으로 적용될 접속 정보(ansible_user, ansible_ssh_pass)나 운영체제(ansible-network_os)는 all 그룹 변수로 지정하여 중복을 피했습니다. 반면, 장비별로 다른 IP 주소 설정을 위해 loopback_id와 같은 호스트 변수를 개별 장비에 직접 할당했습니다.
    ◦ 변수 우선순위: Ansible은 더 구체적인 변수를 우선 적용합니다. 즉, 호스트 변수는 그룹 변수보다, 그룹 변수는 all 그룹의 변수보다 우선순위가 높습니다. 이 원칙 덕분에 유연한 설정 관리가 가능했습니다.
   
• 플레이북(Playbook): 자동화 작업 절차서 플레이북은 자동화할 작업의 절차를 YAML 형식으로 작성한 파일입니다. 하나의 플레이북은 여러 개의 **'플레이(Play)'**로, 하나의 플레이는 여러 개의 **'태스크(Task)'**로 구성됩니다.
    ◦ 플레이(Play): hosts 키를 사용해 어떤 장비 그룹을 대상으로 할지 지정하고, connection: network_cli를 통해 네트워크 장비에 SSH로 접속하도록 설정했습니다.
    ◦ 태스크(Task): 각 태스크는 특정 Ansible 모듈을 실행합니다. 예를 들어, Cisco IOS 장비 설정을 위해 ios_config 모듈을 사용했고, commands 파라미터에 실행할 명령어 목록을 전달했습니다.
   
3. Ansible의 핵심 철학: 멱등성(Idempotency)
이번 실습에서 가장 인상 깊었던 개념은 **멱등성(Idempotency)**입니다. 이는 동일한 플레이북을 여러 번 실행해도 결과가 항상 동일하게 유지되는 특성을 의미합니다.

• 최초 실행: ansible-playbook -i inventory snmp_config.yml 명령어로 처음 플레이북을 실행했을 때, 모듈은 장비의 현재 설정을 확인하고 플레이북에 정의된 내용이 없으면 설정을 추가합니다. 결과는 **changed**로 표시되었습니다.
• 반복 실행: 동일한 플레이북을 다시 실행하자, 모듈은 설정이 이미 원하는 상태와 일치함을 확인하고 아무 작업도 수행하지 않았습니다. 결과는 **ok**로 표시되었습니다.
이 멱등성 덕분에 우리는 스크립트가 불필요한 변경을 일으킬 걱정 없이 언제든 안심하고 플레이북을 실행할 수 있습니다.

5. 더 안전하고 스마트한 실행: Check & Verbose Mode
실제 운영 환경에 변경을 적용하기 전에는 신중함이 필요합니다. Ansible은 이를 위한 강력한 옵션을 제공합니다.
• Check Mode (--check): 'Dry Run' 모드로, 실제 장비 설정을 변경하지 않고 어떤 변경이 일어날지 미리 시뮬레이션해 줍니다. 덕분에 잠재적인 실수를 사전에 방지할 수 있습니다.
• Verbose Mode (-v): 플레이북 실행 과정을 더 상세하게 보여줍니다. 특히 ios_config 모듈이 장비에 어떤 명령어를 보내는지 JSON 데이터 형식으로 확인할 수 있어, 디버깅이나 작업 내용 검토 시 매우 유용했습니다.

저는 이 두 옵션을 함께(-v --check) 사용하여, **"실제 변경 없이, 어떤 명령어가 실행될지 상세히 확인"**하는 안전한 작업 방식을 익힐 수 있었습니다.

7. 실전! 복잡한 설정 다루기 (ios_config 모듈 심화)
단순한 전역 설정뿐만 아니라, 더 복잡한 네트워크 설정도 ios_config 모듈의 다양한 파라미터를 통해 자동화할 수 있었습니다.

• 계층 구조 설정 (인터페이스): parents 인터페이스 설정처럼 특정 설정 모드에 진입한 후 명령어를 입력해야 할 때 parents 파라미터를 사용했습니다. 예를 들어 parents: interface loopback0와 같이 지정하여 해당 인터페이스 설정 모드에서 description이나 ip address를 구성했습니다.
Jinja2 문법({{ loopback_id }})을 활용해 장비별로 다른 IP를 동적으로 할당하는 것도 가능했습니다.

• 순서가 중요한 설정 (ACL): before, match, replace ACL(Access Control List)처럼 설정 순서가 중요하고, 정의된 내용 외에 다른 항목이 없어야 하는 경우는 더 정교한 제어가 필요합니다.
    ◦ before: 설정 변경이 필요할 때만, 주된 작업이 적용되기 전에 먼저 실행할 명령(예: no ip access-list extended INBOUND)을 지정하여 기존 설정을 깔끔하게 삭제할 수 있었습니다.
    ◦ match: exact: ACL 항목이 정확한 순서로 일치하는지 검사합니다. 기본값인 line은 순서를 고려하지 않지만, exact를 사용하면 순서가 어긋났을 때 이를 감지하고 바로잡을 수 있습니다.
    ◦ replace: block: 변경이 감지되었을 때, 바뀐 한 줄만 수정하는 것이 아니라 설정 블록 전체를 교체하도록 합니다. 이를 통해 의도치 않은 설정이 남아있는 것을 방지하고 항상 원하는 상태를 완벽하게 유지할 수 있습니다.
   
### 마치며
이번 실습을 통해 Ansible이 단순히 명령어를 대신 입력해주는 스크립트가 아니라, 네트워크의 '원하는 상태(Desired State)'를 정의하고 유지하는 강력한 도구임을 체감할 수 있었습니다. 인벤토리와 플레이북의 기본 구조부터 멱등성의 개념, 
그리고 복잡한 설정을 다루는 고급 파라미터까지 직접 경험하며 네트워크 자동화에 대한 자신감을 얻게 되었습니다. 
  

