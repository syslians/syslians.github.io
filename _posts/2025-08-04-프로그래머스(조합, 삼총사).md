---
layout: post
title: "프로그래머스 삼총사(조합)"
categories: [알고리즘, 조합]
author: cotes
published: true
---


[문제]

한국 중학교애 다니는 학생들은 각 학생들은 각자 정수 번호를 갖고 있습니다. 이 학교 학생 3명의 정수 번호를 더했을 때 0이 
되면 3명의 학생은 삼총사라고 합니다. 에를 들어, 5명의 학생이 있고, 각각의 정수 번호가 순서대로 -2, 3, 0, 2, -5 일 때,
첫 번째, 세 번쨰, 네 번째 학생의 정수 번호를 더하면 0 이므로 세 학생도 삼총사 입니다. 따라서, 이 경우 한국중학교에서는
두 가지 방법으로 삼총사를 만들 수 있습니다. 또한 두 번 째, 네 번째, 다섯 번째 학생도 삼총사 입니다. 따라서 이 경우 한국
중학교에서는 두 가지 방법으로 삼총사를 만들 수 있습니다.

한국중학교 학생들의 번호를 나타내는 정수 배열 number가 매개변수로 주어질 때, 학생들 중 삼총사를 만들 수 있는 방법의 수를
return 하도록 solutin 함수를 완성하세요.

[제한 사항]
- 3 <= number 의 길이 <= 13
- -1,000 <= number 의 각 원소 <= 1,000
- 서로 다른 학생의 정수 번호가 같을 수 있습니다.

[입출력 예]

| number                   | result |
| ------------------------ | ------ |
| [-2, 3, 0, 2, -5]        | 2      |
| [-3, -2, -1, 0, 1, 2, 3] | 5      |
| [-1, 1, -1, 1]           | 0      |


입출력 예 1
- 문제 예시와 같습니다.
  
입출력 예 2
- 학생들의 정수 번호 쌍 (-3, 0, 3), (-2, 0, 2), (-1, 0, 1), (-2, -1, 3), (-3, 1, 2) 이
  삼총사가 될 수 있으므로, 5를 return 합니다.

입출력 예 3
- 삼총사가 될 수 있는 방법이 없습니다.

중첩 루프 방식 

```java
/** 
number = [a0, a1, a2, a3, a4, a5]
index =   0    1   2   3   4  5

i: 0 ~ 2
j: i+1 ~ 3
k: j+1 ~ 4
**/


class Solution {
  public int solution(int[] number) {
    int n = number.length();

    // 세 학생의 인덱스 i, j, k (i < j < k)
    for (int i=0; i < n -2; i++) {
      for (int j = i + 1; j < n - 1 < j++) {
        for (int k = j + 1; k < n; k++) {
            if (number[i] + number[j] + number[k] == 0) {
              count++;
            }
        }
      }
    } 

    return count;
  }
}
```
[풀이]
순열 조합 문제 입니다. 순서가 중요하지 않으므로 (a, b , c) 와 (a, c, b)는 동일합니다. 
배열길이 n < 13, 3개를 선택하는 조합수는 nC3로 최대 286. 완전탐색 또한 무리 없기에 3중 루프를 사용했습니다. 
모든 조합을 확인하여 합이 0인 조합만 셉니다.

### 시간 복잡도 O(n^3)
- n의 크기가 크지 않다면 충분히 사용 가능합니다. 하지만 n이 크다면 매우 비효율적입니다.

n이 작다면 이 방식이 간단하고 안정적입니다. 만약 성능을 개선시키고 싶다면 정렬 후 투 포인터 등을 사용할 수 있지만,
세 수의 조합은 조합형으로 순회하는게 명확하고 좋습니다.


### 백트래킹 방식

```java
class Solution {
  public int anser;
  public boolean[] visited;

  public int solution(int[] number) {
    visited = new boolean[number.length];
    backtracking(0, 0, 0, number);

    return answer;
  }

  public void backtracking(int index, int depth, int sum, int[] number) {
    if (depth == 3) {
      if (sum == 0) {
        for (int i = 0; i < visited.length; i++) {
          System.out.println(visited[i] + " ");
        }
        answer++;
      }
      return;
    }
  
  for (int i = index; i < number.length; i++) {
    if (!visited[i]) {
      visited[i] = true;
      backtracking(i + 1, depth + 1, sum + number[i], number);
      visited[i] = false;
    }
  }
  }
}

```
[풀이]
- 세 개의 수를 골라서(depth == 3)
- 그 합이 0이면 answer++
- visited 배열로 중복 방지 + index 기반 순서 제어(i+1 부터 재귀)
마찬가지로 N명의 학생 중 3명의 조합을 찾는다는 점은 다를게 없습니다.
조합의 모든 경우의 수를 완전탐색하는 알고리즘에는 백트래킹이 있습니다. DFS는 모든 노드를 방문하는 완전탐색 시
사용되는 알고리즘이고, 백트래킹은 모든 조합을 완전 탐색하는 경우 사용되는 알고리즘 입니다. 하지만 이 코드는
완전탐색이므로 일반적인 백트래킹과는 달리 가지치기를 하지 않습니다.

### 시간 복잡도 O(n^3)
nC3 = (n * (n-1) * (n-2)) / 6
재귀호출 루트를 가집니다. sum == 0 조건 외에는 가지치기가 없으므로 O(n^3)

백트래킹은 for문을 돌려 나올 수 있는 경우의 수마다 재귀호출을 해줍니다. 중복이 되지 않게 하기 위해 for 문의
범위를 이전 인덱스 이후 범위로 설정합니다. 
