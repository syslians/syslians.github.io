---
layout: post
title: "백준11723번(집합, 비트마스크)"
date: 2025-07-27 20:09:00 +0900
categories: [알고리즘]
author: 김현제
---

<문제> 

<비어있는 공집합 S가 주어졌을 때, 아래 연산을 수행하는 프로그램을 작성하시오.>

- add x : S에 x를 추가한다. (1 <= x <= 20) S에 x가 이미 있는 경우에는 연산을 무시한다.
- remove x : S에서 x를 제거한다. (1 <= x <= 20) S에 x가 없는 경우에는 연산을 무시한다.
- check x : S에 x 가 있으면 1을, 없으면 0을 출력한다. (1 <= x <= 20)
- toggle x : S에 x가 있으면 x를 제거하고, 없으면 x를 추가한다. (1 <= x <= 20) 
- all : S를 {1, 2, ..., 20}으로 바꾼다
- empty : S를 공집합으로 바꾼다.

<입력>
첫째 줄에 수행하는 연산의 수 M (1 <= M <= 3,000,000)이 주어진다.
둘째 줄부터 M개의 줄에 수행해야 하는 연산이 한 줄에 하나씩 주어진다.

<출력>
check 연산이 주어질때마다, 결과를 출력한다.

<비트마스크 연산>

add: x번째 비트를 1로 (set |= 1 << (x-1)).
remove: x번째 비트를 0으로 (set &= ~(1 << (x-1))).
check: x번째 비트 확인 (set & (1 << (x-1))).
toggle: x번째 비트 반전 (set ^= 1 << (x-1)).
all: 1~20 비트를 1로 (set = (1 << 20) - 1).
empty: 모든 비트를 0으로 (set = 0).



```java
import java.io.*;
import java.util.StringTokenizer;

public class Main {
  public static void main(String[] args) throws IOException {
   BufferReader br = new BufferReader(new InputStreamReader(System.in));
   StringBuilder sb = new StringBuilder();

   int M = Integer.parseInt(br.readLine()); // 연산 수 입력
   int set = 0; // 비트마스크로 집합 표현 (초기 공집합)

   for (int i = 0; i < M; i++) {
        StringTokenizer st = new StringTokenizer(br.readLine());
        String operation =  st.nextToken(); // 연산 명령어
        int x;

        switch (operation) {
          case "add":
              x = Integer.parseInt(st.nextToken());
              set |= (1 << (x - 1)); // x 번째 비트를 1로 설정 (추가)
            break;
          case "remove":
              x = Integer.parseInt(st.nextToken());
              set &= ~(1 << (x-1)); // x 번째 비트를 0으로 설정 (제거)
            break;
          case "check":
              x = Integer.parseInt(st.nextToken());
              if ((set & (1 << (x-1))) != 0) { // x번째 비트가 1인지 확인
                  sb.append("1\n"); // 있으면 1 추가
              } else {
                  sb.append("0\n"); // 없으면 0 추가
              }
            break;
          case "toggle":
              x = Integer.parseInt(st.nextToken());
              set ^= (1 << (x-1)); // x번째 비트를 revese
            break;
          case "all":
              set = (1 << 20) - 1; // 1 ~ 20 비트를 모두 1로 설정
            break;
          case "empty":
              set = 0; // 모든 비트를 0으로 설정
            break;
        }
   }
    System.out.println(sb);
    br.close();
  }
}
```

### 비트 연산자

- AND 연산 (&) : 대응하는 두 비트가 모두 1일때 1 리턴
- OR 연산 ( | ) : 대응하는 두 비트 중 하나라도 1이라면 1, 아니면 0 릴턴
- XOR 연산( ^ ) : 대응하는 두 비트가 다르다면 1, 같다면 0을 리턴.
- NOT 연산 ( ~ ) : 비트의 값을 반전.
- shift 연산 (<< , >>) : 왼쪽 또는 오른쪽으로 비트를 이동. 쉬프트 연산에서 중요한 점 한가지는 바로 자리수
  입니다. int 자료형은 32 bit 범위를 갖지만 첫 번째 비트는 부호(sign)를 나타내는 정수형이기 때문에 2^31
  까지만 양방향으로 표현할 수 있습니다. 다시 말해, 자료형의 범위를 넘어서는 쉬프트 연산은 Null 값을 얻을 수 있습니다.
- java에서는 16bit 자료형인 char가 부호없는(unsigned) 자료형이므로 bitmask에서 많이 활용합니다.
- java의 경우 int 자료형의 값은 -2^31 ~ 2^31 - 1(-2147483648 ~ 2147483647)을 범위로 갖습니다.

<img width="500" height="682" alt="image" src="https://github.com/user-attachments/assets/f09afaf3-3f81-419f-81a5-02ebc84eaac6" />


### 비트마스킹
> bitmask : 정수형 이진수 표현을 자료구조로 쓰는 기법
이진 숫자로 0, 1 값을 가질 수 있고, 이에 따라 true, false, on/off와 같은 상태를 나타내는 것이 가능합니다.

### 비트마스크 장점

1. 빠른 수행시간
시간복잡도 O(1)에 구현되는 것이 많습니다. 비트마스크를 사용할 수 있다는 말은 원소의 수가 많지 않다는 뜻이기 때문에, 큰 속도 향상을 
기대할수는 없지만 여러번 수행해야 하는 경우에는 작은 최적화도 큰 속도 향상을 가져올 수 있습니다.

2. 간결한 코드
집합 연산자들을 반복문 없이 한 줄에 쓸 수 있습니다.

3. 작은 메모리 사용량
작은 메모리를 사용할 수 있다는 말은 데이터를 미리 계산하여 저장해둘 수 있ㅇ으므로 캐시 효율이 좋다는 말입니다.

4. 연관 배열을 배열로 대체
예로 연관 배열 객체 Map<Vector, int>가 있다고 합시다. 이 때 비트마스크를 이용해 정수 변수로 나타내면 단순배열 int[]로 사용할 수 있습니다.

### 용어 정의
- 비트(bit) : 0과 1로 나타내는 이진수의 한 자리
- 부호 없는 N 비트 값 : 값 20 ~ 2N-1
- 최하위비트(LSB) : 20에 위치한 비트
- 최상위 비트(MSB) : 2N - 1에 위치한 비트
- 비트가 켜져 있다 : 1
- 비트가 꺼져 있다 : 0

### 비트마스크를 이용한 집합 구현
비트마스크를 이용한 집합 구현은 가장 대표적이고, 자주 쓰이는 방법입니다. 하나의 bit가 하나의 데이터 상태를 의미합니다. bit가 1이면 해당
원소가 집합에 포함되어 있다는 의미이고, 0이면 포함되어 있지 않다는 의미입니다. 따라서, N 비트는 N개의 원소를 갖는 집합의 부분집합들을 모두
표현할 수 있습니다.

### 공집합과 꽉 찬 집합 구하기
> int A = 0;
> A = (1 << 10) - 1;
기본적으로 공집합은 bit가 모두 꺼진 상화이기 때문에 상수 0이 공집합을 표현합니다. 반대로 꽉 찬 집합은 bit가 모두 켜진 상황이기 떄문에
1111111111(2)의 값으로 표현한다.

### 원소 추가
> A |= (1 << k);
A 집합에 특정 원소를 추가하는 방법입니다. 원소에 해당하는 bit만 켜야 하기 때문에 해당 bit를 항상 1로 만드는 연산이 필요하기 때문에 OR 
연산을 이용합니다.

### 원소 삭제
> A &= ~(1 << k);
A 집합에 포함된 특정 원소를 삭제하는 방법입니다. A에 k번째 원소의 포함 여부와 상관없이 해당 bit를 끄기 위해서는 AND 연산을 이용해야 합니다.
- 1 << k : k번째가 켜진 상태
- 1 ^ (1 << k) : k번째만 꺼진 상태
- A &= ^(1 << k); : A 집합에 담긴 k번째 상태 off

### 원소의 포함 여부 확인
> if((A & (1 << k)) == (1 << k))
A 집합에 특정 원소가 포함되어 있는지 확인하는 방법입니다. k번째 원소가 포함되어 있는지 확인하고 싶다면, k번째 bit가 켜져 있는지만 확인하면
됩니다.

### 원소의 토글
> A ^= (1 << k);
A 집합에 해당 원소가 빠져있는 경우에는 추가하고, 들어있는 경우에만 삭제하는 방법입니다. XOR 연산을 이용합니다.

### 두 집합에 대해 연산하기
> A | B    // A와 B의 합집합
> A & B    // A와 B의 교집합
> A & (~B) // A에서 B를 뺀 차집합
> A ^ B    // A와 B 중 하나에만 포함된 원소들의 집합
두 집합을 A와 B라고 한다면, 비트연산자들을 통해서 A와 B의 교집합, 합집합, 차집합 등을 구할 수 있습니다.

### 집합의 크기 구하기
```java
int bitCount(int A) {
  if(A == 0) return 0;

  return A % 2 + bitCount(A / 2);
}

// 내장 명령어
Integer.bitCount(A);
```

### 최소 원소 찾기
> int first = A & (-A);
집합에 포함된 가장 작은 워소(index가 가장 작은 원소)를 찾는 방법입니다. 켜져있는 bit 중에서 가장 오른쪽에 있는 bit를 찾는것입니다.
비트마스크 뿐만 아니라 Fenwick Tree에서도 사용되는 기법입니다.

비트 A가 있다고 합시다.
1. 가장 오른쪽에 켜져있는 bit를 k라고 한다면, 0 ~ k-1의 비트는 모두 0이다.
2. 그렇다면 -A 에서는 k번째 bit는 0, 0 ~ k-1의 bit는 모두 1입니다.
3. ~A + 1을 하게 되면 k번째 bit는 1, 0 ~ (k-1)의 bit는 모두 0이 됩니다. k 이후의 비트는 아무 변화가 없습니다.
(~A + 1 : 컴퓨터가 표현하는 A의 2의 보수 (-A))

따라서, -A와 A를 AND 연산을 시키면 K번째 bit만 켜진 상태로 남게 됩니다.
```java
int first = A & (-A);
A : 1010, -A + 1 : 0110, A & (-A) : 0010
```

### 최소 원소 지우기
> A &= (A - 1);
가장 오른쪽에 켜져 있는 bit를 지우고 싶다면 A-1과 AND 시키면 됩니다. A에서 1을 빼주게 되면 가장 오른쪽에 있던 bit는 0이 되고
그보다 오른쪽에 있는 모든 bit들이 1이 되기 때문입니다.
```java
A &= (A - 1);
A : 1010, A - 1 : 1001, A & (A - 1) : 1000
```

비트마스크, 집합 문제를 처음 접했을 때, 최대 3,000,000번의 연산을 1.5초 내에 처리해야 한다는 점이 가장 큰 어려움이였습니다. 
초기에 ArrayList를 사용해 집합을 관리하려 했지만, indexOf나 contains 같은 메서드의 O(n)시간 복잡도로 인해 시간 초과가 발생했습니다. 
ArrayList 기반 코드에서도 드러난 문제로, 특히 all 연산의 잘못된 구현(Collections.sort)과 반복적인 BufferedWriter.flush() 호출이 비효율적이었습니다. 
비트마스크와 비트 연산(&, |, ^, ~, <<)에 익숙하지 않아, 처음에는 비트가 어떻게 집합을 표현하는지 이해하기 어려웠습니다. 

초기 접근: ArrayList로 숫자(1~20)를 저장하고, add, remove, check, toggle 연산을 리스트 메서드로 구현.
문제점:

indexOf 호출이 연산당 O(n), 총 O(M \cdot n) (최악 $ n=20).
all 연산에서 {1, 2, ..., 20}을 설정하려면 리스트에 모든 숫자를 추가해야 해 비효율적.
check마다 System.out.println 호출로 I/O 오버헤드 증가.


결과: $ M=3,000,000일 때 시간 초과.

해결 방법

비트마스크 도입: 단일 int(32비트)로 집합을 표현(집합의 크기가 20비트이기에 int 자료형으로 충분). 
각 비트가 숫자(1~20)의 포함 여부를 나타냄. 

예: {1, 3} → ...000101 (1번, 3번 비트 1).
비트 연산으로 add, remove, check, toggle을 $ O(1)로 처리.


출력 최적화: StringBuilder로 check 결과를 모아 한 번에 출력, I/O 시간 최소화.
정확한 all 구현: (1 << 20) - 1로 1~20 비트를 모두 1로 설정.
메모리 효율: 단일 int(4바이트)로 관리, 4MB 제한 내 충분.


참조: https://myeongju00.tistory.com/m/30,https://kwanik.tistory.com/3
