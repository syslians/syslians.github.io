---
layout: post
title: "Zero-Copy"
date: 2025-07-27 22:00:00 +0900
categories: [Zero-Copy, Kafka, Linux, OS, DMA]
author: cotes
published: true
---


- IBM Developer Java Zero-Copy 글 리뷰
Kafka가 흔히 빠른 이유를 말하라고 하면 Zero-Copy 기술을 이야기합니다. 관련 기술 글 중에서 IBM에서 정리한 좋은 자료가 있어 리뷰해봅니다. https://developer.ibm.com/articles/j-zerocopy/

-----------------------

## 1.Zero-Copy
아티클은 먼저 고성능 I/O가 필요한 서버 환경을 전제로 이야기를 시작합니다. 대표적으로 파일 서버, 스트리밍 서버, 대용량 데이터 전송 시스템을 언급하며
이러한 환경에서는 CPU 사용률과 메모리 복사 비용이 주요 병목이 된다고 이야기합니다.

즉, 문제의 출발점은 다음 질문입니다.

"데이터를 전달만 하는데 왜 이렇게 CPU를 많이 쓰는가?"

IBM은 이 원인이 전통적인 I/O 모델에서 발생하는 불필요한 메모리 복사에 있다고 설명합니다.

-----------------------

## 2. 전통적인 I/O 방식 설명
다음 문단에서는 기존 I/O 모델의 동작 방식을 설명합니다.

일반적으로 Java에서 파일을 읽어 네트워크로 전송할때의 흐름은 다음과 같습니다.

1. 디스크의 파일을 읽어 커널 버퍼에 적재
2. 커널 버퍼에서 사용자 공간(Java 애플리케이션)의 버퍼로 복사
3. 사용자 공간 버퍼에서 다시 커널 소켓 버퍼로 복사
4. 네트워크 카드(NIC)를 통해 전송

<img width="2220" height="800" alt="image 1" src="https://github.com/syslians/syslians.github.io/blob/master/assets/img/favicons/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202026-01-29%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.17.06.png">



파일서버나 정적 파일을 서비스하는 웹 어플리케이션은 디스크에서 파일 컨텐츠를 읽어 네트워크 소켓으로 데이터를 전송하는 일을 반복적으로 수행합니다. 
이 글에서는 이 과정에서 같은 데이터가 여러번 반복 복사되고, 불필요한 컨텍스트 스위칭이 수반됩니다. 아래 코드를 보면 read() 이후 send()를 수행하는 간단한 코드지만
4번의 컨텍스트 스위칭과 4개의 메모리 복사본이 생기게 됩니다.

```
byte applicationBuffer = new byte[1024];

read(fileFd, applicationBuffer, len);
send(socketFd, applicationBuffer, len);
```


<img width="2220" height="800" alt="image 1" src="https://github.com/syslians/syslians.github.io/blob/master/assets/img/favicons/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202026-01-29%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.17.12.png">

- 커널 <-> 사용자 공간 간 복사
- read(), write() 시스템 콜
- 컨텍스트 스위칭
이 반복되며 CPU 리소스를 소비한다고 설명합니다.


-----------------

### 3. Java 환경에서의 추가 비용
IBM 아티클은 Java라는 환경이 이 문제를 더 크게 만들수 있다고 설명합니다.

Java에서는 보통 
- byte []
- ByteBuffer
와 같은 객체를 사용해 데이터를 다루는데, 이는 곧 JVM 힙 메모리 사용 증가를 의미합니다.

그 결과 
- 객체 생성 비용
- GC 대상 객체 증가
- GC pause 가능성 증가
라는 부가적인 오버헤드가 발생합니다.

IBM은 이 시점에서 중요한 관점을 제시합니다. "데이터를 가공하지도 않는데, 굳이 사용자 공간으로 가져와야 할 이유가 있는가?"

--------------

### 4. Zero-Copy 개념 도입
이 질문에 대한 답으로 등장하는 개념이 Zero-Copy 입니다. IBM 아티클에서 설명하는 Zero-Copy의 핵심은 다음과 같습니다.

| 데이터를 사용자 공간으로 복사하지 않는다.


여기서 Zero-Copy란 메모리 복사가 완전히 0이라는게 아니라 사용자 공간으로의 복사를 제거한다는 의미입니다.

운영체제는 이미 파일 데이터를 네트워크 소켓으로 직접 전달하는 기능을 제공하고 있으며, 이를 활용하면 불필요한 복사를 줄일 수 있다고 설명합니다.

### 5. OS 레벨의 Zero-Copy: sendfile
IBM은 Zero-Copy의 대표적인 OS 기능으로 Linux의 sendfile() 시스템 콜을 언급합니다.

sendfile()은 다음과 같은 역할을 합니다.
- 파일 디스크립터와 소켓 디스크립터를 직접 연결
- 파일 데이터를 사용자 공간으로 올리지 않고
- 커널 내부에서 파일 -> 소켓 전송 수행

즉, 애플리케이션은 데이터를 읽거나 쓰지 않고, 단지 전송을 요청 한다. 
IBM은 이 구조가 고성능 네트워크 서버에서 매우 효율적이라고 설명합니다.

---------------------

## 6. Java에서 Zero-Copy를 사용하는 방법

다음 문단에서는 Java에서 이 OS 기능을 어떻게 사용할 수 있는지를 설명합니다.
Java NIO는 이를 위해 다음과 같은 API를 제공합니다.
```
FileChannel.transferTo(...)
FileChannel.transferFrom(...)
```



IBM은 이 메서드들이 내부적으로
- 운영체제의 sendfile()과 같은 기능을 활용하여
- 파일 데이터를 직접 소켓으로 전송한다고 설명합니다.

중요한 점은, 
- Java 힙에 데이터가 올라오지 않는다
- 애플리케이션 코드에서 byte[]를 다루지 않는다

<img width="2220" height="800" alt="image 1" src="https://github.com/syslians/syslians.github.io/blob/master/assets/img/favicons/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202026-01-29%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.51.04.png">

<img width="2220" height="800" alt="image 1" src="https://github.com/syslians/syslians.github.io/blob/master/assets/img/favicons/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202026-01-29%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.51.12.png">
--------

## 7. Zero-Copy 사용시 데이터 흐름
기존 방식

```
Disk
 → Kernel Buffer
 → User Buffer (JVM)
 → Kernel Socket Buffer
 → NIC

```

Zero-Copy 방식

```
Disk
 → Kernel Page Cache
 → Kernel Socket Buffer
 → NIC
```

여기서 핵심 변화는
- User Buffer 단계가 사라졌다는 점
- JVM 힙과 GC가 전혀 관여하지 않는다는 점

IBM은 이것이 CPU 사용률 감소, 메모리 복사 감소, 전송 처리량 향상 으로 이어진다고 설명합니다.

## 8. Socket Buffer 조차 건너뛰는 진짜 Zero-Copy (DMA)

사용자 공간(User Space) 복사는 제거되었지만, 커널 내부에서의 복사까지 완전히 사라졌다고 볼수는 없습니다.
여기서 한단계 더 내려가면, 일부 환경에서는 Socket Buffer 조차 건너뛰는 데이터 복사 방식이 가능합니다.

### DMA (Direct-Memory Access) 기반 전송이란?
DMA는 CPU가 데이터를 직접 복사하지 않고, 디바이스가 메모리로부터 직접 데이터를 읽거나 쓰는 방식입니다.

네트워크 전송 관점에서 보면 NIC이 커널 페이지 캐시를 직접 참조하여 전송할수 있습니다. 이 경우 CPU는 데이터 복사 작업에 관여하지 않습니다.
현대 NIC은 보통 Scatter/Gather DMA를 지원합니다.

이는 연속되지 않은 여러 메모리 페이지를 하나의 네트워크 패킷 스트림처럼 전송하는 기능입니다. 이 조건이 충족되면 파일 데이터는 이미 Page Cache에 있고,
NIC이 해당 페이지들을 직접 읽어 네트워크로 전송합니다.

<img width="2220" height="800" alt="image 1" src="https://github.com/syslians/syslians.github.io/blob/master/assets/img/favicons/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202026-01-29%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.23.58.png">


---------------

## 8. Zero-Copy의 효과가 큰 사용 사례
아티클 후반부에서는 Zero-Copy가 특히 효과적인 경우를 언급합니다.

대표적인 예는:
- 정적 파일 다운로드
- 미디어 스트리밍
- 대용량 파일 전송 서버

이러한 경우에는 데이터 가공이 없고, 파일을 그대로 전달하기만 하면 되기 때문에 Zero-Copy의 장점을 최대한 활용할 수 있다고 설명합니다.

성능상의 실제 이점을 실험결과로 나타낸 표를 보면 더 정확합니다. 리눅스 2.6 커널 버전을 사용했으며 전통적인 파일 전송과 transferTo() 메서드를 사용한 파일전송 성능 결과 비교입니다.


|File size |	Normal file transfer (ms)	| transferTo (ms)|
|----------|--------------------------|----------------|
|7MB	| 156 |	45 |
| 21MB |	337	| 128 |
| 63MB |	843 |	387 |
| 98MB |	1320 |	617 |
| 200MB |	2124	| 1150 | 
| 350MB |	3631 |	1762 |
| 700MB |	13498 |	4422 |
| 1GB |	18399 |	8537 |

실험결과에서 보듯이 transferTo() 메서드는 기존 방식에 비해 65%의 성능상의 이점을 가져다주는것을 볼 수 있습니다. 이는 매우 큰차이이입니다. 


### 정리 

IBM의 Java Zero-Copy 아티클은, 전통적인 I/O 구조의 비용을 설명하고, 사용자 공간 복사의 문제점을 짚은 뒤, Java NIO API를 통해 이를 어떻게 줄일 수 있는지 소개하는 글입니다.




